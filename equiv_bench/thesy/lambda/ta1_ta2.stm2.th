(datatype Nat () ((succ Nat Nat) (zero Nat)))
(datatype Lambda () ((V Nat Lambda) (P Nat Lambda Lambda) (C Lambda Lambda Lambda)))
(datatype Lst () ((nil Lst) (cons Nat Lst Lst)))

(declare-fun append (Lst Lst) Lst)
(=> rule0 (append nil ?x) ?x)
(=> rule1 (append (cons ?x2 ?y) ?z) (cons ?x2 (append ?y ?z)))

(declare-fun mem (-> (Nat (List Nat)) Bool))
(=> rule (mem ?n Nil          ) False                            )
(=> rule (mem ?n (Cons ?x ?xs)) (ite (eq ?n ?x) True (mem ?n ?xs)))

(declare-fun check1 (-> (Lambda (List Nat)) Bool))
(=> rule (check1 (V ?x) ?lst) (mem ?x ?lst))
(=> rule (check1 (P ?x ?e) ?lst) (check1 ?e (Cons ?x ?lst)))
(=> rule (check1 (C ?e1 ?e2) ?lst) (and (check1 ?e1 ?lst) (check1 ?e2 ?lst)))

(declare-fun ta1 (-> (Lambda) Bool))
(=> rule (ta1 ?lambda) (check1 ?lambda Nil))

(declare-fun ta2 (-> (Lambda) Bool))
(=> rule (ta2 (V ?x)) False)
(=> rule (ta2 (P ?x ?e)) (check1 ?e (Cons ?x Nil)))
(=> rule (ta2 (C ?e1 ?e2)) (and (check1 ?e1 Nil) (check1 ?e2 Nil)))

(declare-fun check3 (-> (Lmabda (List Nat)) Bool))
(=> rule (check3 (P ?st ?k) ?li) (ite (mem ?st ?li) (check3 ?k ?li) (check3 ?k (Cons ?st ?li))))
(=> rule (check3 (C ?me1 ?me2) ?li) (and (check3 ?me1 ?li) (check3 ?me2 ?li)))
(=> rule (check3 (V ?na) ?li) (mem ?na ?li))

(declare-fun ta3 (-> (Lambda) Bool))
(=> rule (ta3 ?lambda) (check3 ?lambda Nil))

(declare-fun exist (-> ((-> (Nat) Bool) (List Nat)) Bool))
(=> rule (exist ?p Nil) False)
(=> rule (exist ?p (Cons ?hd ?tl)) (or ($ ?p ?hd) (exist ?p ?tl)))

(declare-fun check4 (-> (Lambda (List Nat)) Bool))
(=> rule (check4 (P ?st ?k) ?li) (check4 ?k (Cons ?st ?li)))
(=> rule (check4 (C ?me1 ?me2) ?li) (and (check4 ?me1 ?li) (check4 ?me2 ?li)))
(=> rule (check4 (V ?na) ?li) (exist (eq ?na) ?li))

(declare-fun ta4 (-> (Lambda) Bool))
(=> rule (ta4 (P ?st ?k)) (check4 ?k (Cons ?st Nil)))
(=> rule (ta4 (C ?me1 ?me2)) (and (check4 ?me1 Nil) (check4 ?me2 Nil)))
(=> rule (ta4 (V ?na)) False)

(declare-fun list-filter (-> ((-> (a a) Bool) a (List a)) (List a)))
(=> rule (list-filter ?p ?x Nil) Nil)
(=> rule (list-filter ?p ?x (Cons ?hd ?tl)) (ite ($ ?p ?x ?hd) (Cons ?hd (list-filter ?p ?x ?tl)) (list-filter ?p ?x ?tl)))

(declare-fun sol5 (-> (Lambda) Bool))
(=> rule (sol5 ?lambda) (eqlist (getStn ?lambda) Nil))
(declare-fun getStn (-> (Lambda) (List Nat)))
(=> rule (getStn (V ?var)) (Cons ?var Nil))
(=> rule (getStn (P ?n ?m)) (list-filter aux ?n (getStn ?m)))
(=> rule (getStn (C ?m1 ?m2)) (append (getStn ?m1) (getStn ?m2)))
(declare-fun aux (-> (Nat Nat) Bool))
(=> rule (aux ?n ?m) (not (eq ?n ?m)))

(declare-fun sol50 (-> (Lambda) Bool))
(=> rule (sol50 ?m) (findStation ?m (V Z)))
(declare-fun findStation (-> (Lambda Lambda) Bool))
(=> rule (findStation (V ?n) ?covers) (valify ?n ?covers))
(=> rule (findStation (P ?n ?m) ?covers) (findStation ?m (P ?n ?covers)))
(=> rule (findStation (C ?m1 ?m2) ?covers) (and (findStation ?m1 ?covers) (findStation ?m2 ?covers)))
(declare-fun valify (-> (Nat Lambda) Bool))
(=> rule (valify (?var V ?n)) False)
(=> rule (valify (?var P ?n ?m)) (ite (eq ?n ?var) True (valify ?var ?m)))
(=> rule (valify (?var C ?m1 ?m2)) False)

(declare-fun sol57 (-> (Lambda) Bool))
(=> rule (sol57 ?l) (eqlist (listStation ?l) Nil))
(declare-fun listStation (-> (Lambda) (List Nat)))
(=> rule (listStation (V ?n)) (Cons ?n Nil))
(=> rule (listStation (P ?n ?m)) (deleteAll (listStation ?m) ?n))
(=> rule (listStation (C ?m1 ?m2)) (append (listStation ?m1) (listStation ?m2)))
(declare-fun deleteAll (-> ((List Nat) Nat) (List Nat)))
(=> rule (deleteAll Nil ?target) Nil)
(=> rule (deleteAll (Cons ?hd ?tl) ?target) (ite (eq ?hd ?target) (deleteAll ?tl ?target) (Cons ?hd (deleteAll ?tl ?target))))


(declare-fun sol101 (-> (Lambda) Bool))
(=> rule (sol101 ?m) (check101 ?m Nil Nil))
(declare-fun check101 (-> (Lambda (List Nat) (List Nat)) Bool))
(=> rule (check101 (V ?n) ?al ?nl) (forall101 aux101 ?al (Cons ?n ?nl)))
(=> rule (check101 (P ?n ?m) ?al ?nl) (check101 ?m (Cons ?n ?al) ?nl))
(=> rule (check101 (C ?m1 ?m2) ?al ?nl) (and (check101 ?m1 ?al ?nl) (check101 ?m2 ?al ?nl)))
(declare-fun forall101 (-> ((-> (Nat (List Nat)) Bool) (List Nat) (List Nat)) Bool))
(=> rule (forall101 ?pred ?a Nil) True)
(=> rule (forall101 ?pred ?a (Cons ?hd ?tl)) (ite ($ ?pred ?hd ?a) (forall101 ?pred ?a ?tl) False))
(declare-fun aux101 (-> (Nat (List Nat)) Bool))
(=> rule (aux101 ?x ?al) (mem ?x ?al))
(// sol101 is something wrong....//)

(declare-fun sol109 (-> (Lambda) Bool))
(=> rule (sol109 ?l) (checkRec ?l Nil))
(declare-fun checkRec (-> (Lambda (List Nat)) Bool))
(=> rule (checkRec (V ?var) ?lst) (varExists ?var ?lst))
(=> rule (checkRec (P ?var ?l) ?lst) (checkRec ?l (addToNameList ?var ?lst)))
(=> rule (checkRec (C ?l1 ?l2) ?lst) (and (checkRec ?l1 ?lst) (checkRec ?l2 ?lst)))
(declare-fun addToNameList (-> (Nat (List Nat)) (List Nat)))
(=> rule (addToNameList ?var ?lst) (ite (varExists ?var ?lst) (?lst) (Cons ?var ?lst)))
(declare-fun varExists (-> (Nat (List Nat)) Bool))
(=> rule (varExists ?var Nil) False)
(=> rule (varExists ?var (Cons ?h ?t)) (ite (eq ?var ?h) True (varExists ?var ?t)))

(declare-fun sol123 (-> (Lambda) Bool))
(=> rule (sol123 ?m) (ite (is-connect ?m) (and (sol123 (get-left ?m)) (sol123 (get-right ?m))) (aux123 ?m)))
(declare-fun aux123 (-> (Lambda) Bool))
(=> rule (aux123 (V ?n)) False)
(=> rule (aux123 (C ?l ?r)) (and (sol123 ?l) (sol123 ?r)))
(=> rule (aux123 (P ?v ?l)) (match123 ?l ?v))
(declare-fun match123 (-> (Lambda Nat) Bool))
(=> rule (match123 (V ?s) ?var) (ite (eq ?var ?s) True False))
(=> rule (match123 (C ?l1 ?l2) ?var) (and (sol123 (P ?var ?l1)) (sol123 (P ?var ?l2))))
(=> rule (match123 (P ?v ?l) ?var) (or (sol123 (P ?var ?l)) (sol123 (P ?v ?l))))
(declare-fun get-right (-> (Lambda) Lambda))
(=> rule (get-right (V ?n)) (V ?n))
(=> rule (get-right (C ?l1 ?l2)) ?l2)
(=> rule (get-right (P ?v ?l)) (P ?v (get-right ?l)))
(declare-fun get-left (-> (Lambda) Lambda))
(=> rule (get-left (V ?n)) (V ?n))
(=> rule (get-left (C ?l1 ?l2)) ?l1)
(=> rule (get-left (P ?v ?l)) (P ?v (get-left ?l)))
(declare-fun is-connect (-> (Lambda) Bool))
(=> rule (is-connect (V ?n)) False)
(=> rule (is-connect (C ?l1 ?l2)) True)
(=> rule (is-connect (P ?v ?l)) (is-connect ?l))

(declare-fun sol530 (-> (Lambda) Bool))
(=> rule (sol530 ?m) (eq (ck530 ?m Nil) Z))
(declare-fun ck530 (-> (Lambda (List Nat)) Nat))
(=> rule (ck530 (V ?va) ?lst) (ite (mem ?va ?lst) (Z) (S Z)))
(=> rule (ck530 (C ?ex1 ?ex2) ?lst) (plus (ck530 ?ex1 ?lst) (ck530 ?ex2 ?lst)))
(=> rule (ck530 (P ?va ?ex) ?lst) (ck530 ?ex (Cons ?va ?lst)))
