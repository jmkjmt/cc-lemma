(
(data Bool (True False))
(:: True Bool)
(:: False Bool)

(data Nat (Z S))
(:: Z Nat)
(:: S (-> (Nat) Nat))

(data Pair (a b) (Pair))
(:: Pair (-> (a b) (Pair a b)))

(data List (a) (Nil Cons))
(:: Nil  (List a)                    )
(:: Cons (-> (a (List a)) (List a)))

(data Tree (a) (Leaf Node))
(:: Leaf (Tree a)                              )
(:: Node (-> ((Tree a) a (Tree a)) (Tree a)))

(data Tm (a) (Var Cst App))
(:: Var (-> (a                 ) (Tm a)))
(:: Cst (-> (Nat                ) (Tm a)))
(:: App (-> ((Expr a) (Expr a)) (Tm a)))

(data Expr (a) (MkExpr))
(:: MkExpr (-> ((Tm a) Nat) (Expr a)))

(:: id (-> (a) a))
(let id (?x) ?x)

(:: comp (-> ((-> b c) (-> a b) (a)) c))
(let comp (?f ?g ?x) ($ ?f ($ ?g ?x)))

(:: const (-> (a b) a))
(let const (?x ?y) ?x)

(:: ite (-> (Bool a a) a))
(let ite (True ?x ?y ) ?x)
(let ite (False ?x ?y) ?y)
(// (let ite (?b    ?x ?x) ?x))

(:: not (-> (Bool) Bool))
(let not True False)
(let not (False) True)

(:: and (-> (Bool Bool) Bool))
(let and (False ?y) False)
(let and (?x False) False)
(let and (True True) True)

(:: or (-> (Bool Bool) Bool))
(let or (True ?y) True)
(let or (?x True) True)
(let or (False False) False)

(:: plus (-> (Nat Nat) Nat))
(let plus (Z      ?y) ?y             )
(let plus ((S ?x) ?y) (S (plus ?x ?y)))

(:: sub (-> (Nat Nat) Nat))
(let sub (?x Z)          ?x         )
(let sub (Z ?y)          Z          )
(let sub ((S ?x) (S ?y)) (sub ?x ?y))

(:: leq (-> (Nat Nat) Bool))
(let leq (Z      ?y) True           )
(let leq ((S ?x) Z ) False          )
(let leq ((S ?x) (S ?y)) (leq ?x ?y))

(:: lt (-> (Nat Nat) Bool))
(let lt (?x     Z     ) False     )
(let lt (Z      (S ?y)) True      )
(let lt ((S ?x) (S ?y)) (lt ?x ?y))

(:: eq (-> (Nat Nat) Bool))
(let eq (Z      Z     ) True      )
(let eq (Z      (S ?y)) False     )
(let eq ((S ?x) Z     ) False     )
(let eq ((S ?x) (S ?y)) (eq ?x ?y))

(:: len (-> ((List a)) Nat))
(let len (Nil          ) Z            )
(let len ((Cons ?x ?xs)) (S (len ?xs)))

(:: mem (-> (Nat (List Nat)) Bool))
(let mem (?n Nil          ) False                            )
(let mem (?n (Cons ?x ?xs)) (ite (eq ?n ?x) True (mem ?n ?xs)))

(:: append (-> ((List a) (List a)) (List a)))
(let append (Nil           ?ys) ?ys                       )
(let append ((Cons ?x ?xs) ?ys) (Cons ?x (append ?xs ?ys)))

(:: rev (-> ((List a)) (List a)))
(let rev (Nil          ) Nil                             )
(let rev ((Cons ?x ?xs)) (append (rev ?xs) (Cons ?x Nil)))

(:: rotate (-> (Nat (List a)) (List a)))
(let rotate (Z ?x) ?x)
(let rotate ((S ?n) Nil) Nil)
(let rotate ((S ?n) (Cons ?x ?xs)) (rotate ?n (append ?xs (Cons ?x Nil))))

(=== clam_32 (x) ((List a))
  (rotate (len x) x)
  x
)

)
